// @flow
import {
  describe, it, before, after,
} from 'mocha';
import { Entry } from '../claim/entry/entry';
import { NameResolver, testNamesJSON } from '../http/name-resolver';
import { Discovery, testEntitiesJSON } from '../http/discovery';
import { SignedPacketVerifier } from './login';

const chai = require('chai');

const { expect } = chai;

const snarkjs = require('snarkjs');
const iden3 = require('../index');
const smt = require('../sparse-merkle-tree/sparse-merkle-tree');

const { bigInt } = snarkjs;
const relayKOpAddr = '0xe0fbce58cfaa72812103f003adce3f284fe5fc7c';
const usrAddr = '0x308eff1357e7b5881c00ae22463b0f69a0d58adb';

// following proofEthName and proofKSign are generated by go-iden3
const proofEthName = {
  ethName: 'usertest@iden3.io',
  proofAssignName: {
    signer: '0x0123456789abcdef0123456789abcdef01234567',
    date: 1551457426,
    leaf: '0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000308eff1357e7b5881c00ae22463b0f69a0d58adb0006e87e2d5265f1ea2ce3882864eb871263080c73ba1d4bfe89288a028f90300000000000000000000000000000000000000000000000000000000000000003',
    proofs: [
      {
        aux: null,
        mtp0: '0x0000000000000000000000000000000000000000000000000000000000000000',
        mtp1: '0x030000000000000000000000000000000000000000000000000000000000000029c74f748e1ad9cf64ecc6f3bbc3d3ab5a318798d9a1eaa6c889f70d04dc64ea116f9ac9335ac96ec780b18bf4b82ab0b39e661e4818116226ffb2d2acb9ece2',
        root: '0x104aa547b930b441f924fdb02dcb44b4983efe136c6e5a9682c5b808fd3be6da',
      },
    ],
    signature: '0x6851319f83759ad8ebb168ed6fb940c06933587cabd6f04cf08b74e4abbf0a8b0556da6f3124902cf0f0c74b9e432a2a74b9fe0bfc1b7e6d59da1332b3b24c341b',
  },
};

const proofKSign = {
  signer: '0x0123456789abcdef0123456789abcdef01234567',
  date: 1551457426,
  leaf: '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003c2e48632c87932663beff7a1f6deb692cc61b041262ae8f310203d0f5ff50000000000000000000000000000000000007833000000000000000000000004',
  proofs: [
    {
      aux: {
        version: 0,
        era: 0,
        idAddr: '0x308eff1357e7b5881c00ae22463b0f69a0d58adb',
      },
      mtp0: '0x0000000000000000000000000000000000000000000000000000000000000000',
      mtp1: '0x030000000000000000000000000000000000000000000000000000000000000028f8267fb21e8ce0cdd9888a6e532764eb8d52dd6c1e354157c78b7ea281ce801541a6b5aa9bf7d9be3d5cb0bcc7cacbca26242016a0feebfc19c90f2224baed',
      root: '0x1d9d41171c4b621ff279e2acb84d8ab45612fef53e37225bdf67e8ad761c3922',
    }, {
      aux: null,
      mtp0: '0x0000000000000000000000000000000000000000000000000000000000000000',
      mtp1: '0x030000000000000000000000000000000000000000000000000000000000000021c9cceb8a61605050a029cecda7e36eeaffef11910778b3e5ea32f79659cee125451237d9133b0f5c1386b7b822f382cb14c5fff612a913956ef5436fb6208a',
      root: '0x0b109c78f2679a405cc0b5a8d999129ee4429e86a986b8001e0a4df61c359690',
    },
  ],
  signature: '0xb0ef961c13cfa373fb40e7de7e523eb2571708e0852425cf1878a9f1b04f04ab42952f1d9525ea04be867fed7b27aca1caf1ea1422eceedbd61d641537a94ae31b',
};

describe('[protocol]', () => {
  let db;
  let kc;
  let kOperational;
  let signedPacketVerifier;

  before('initialize objects', () => {
    const discovery = new Discovery(testEntitiesJSON);
    const nameResolver = new NameResolver(testNamesJSON);
    signedPacketVerifier = new SignedPacketVerifier(discovery, nameResolver);
    db = new iden3.Db();
    kc = new iden3.KeyContainer('localStorage', db);
    kc.unlock('pass');
  });

  after('lock key container', () => {
    kc.lock();
  });

  it('create operation key', () => {
    const mnemonic = 'enjoy alter satoshi squirrel special spend crop link race rally two eye';
    kc.generateMasterSeed(mnemonic);
    const mnemonicDb = kc.getMasterSeed();
    kc.generateKeySeed(mnemonicDb);
    const { keySeed, pathKey } = kc.getKeySeed();
    const objectKeys = kc.generateKeysFromKeyPath(keySeed, pathKey);
    const { keys } = objectKeys;
    const kSign = keys[1];
    kOperational = kSign;
  });

  it('test bigint', () => {
    // check that node version supports shiftLeft on bigInt
    bigInt(8).toString();
    bigInt(8).shiftLeft(2);
  });

  it('test check proof', () => {
    const leaf = '0x'
    + '0000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000393939393939393939393939393939393939393a'
    + '00d67b05d8e2d1ace8f3e84b8451dd2e9da151578c3c6be23e7af11add5a807a'
    + '0000000000000000000000000000000000000000000000010000000000000003';
    const proof = '0x'
    + '000600000000000000000000000000000000000000000000000000000000002f'
    + '096c4844ff1a371253894c44bbc7b79915ba5a08868a19cdd4ff669ba5bf4d67'
    + '0ce08b5f71063762286214277d6d46ee0ecc1430f214daf597966c71f681ada2'
    + '25ae1d27a7d498d5eded2d259bac59899ea063135e91d989f5a163425de75dd2'
    + '0cf77fa54111c30805962fb39fad88302d250dca1de63c71dd3a95ba5c11450e'
    + '20696d87aeec38c4fb986bdfb6bed824173370cfd75cb4a8e907900278054d68';
    const root = '0x143ff097f932cd5f9964323cd1225cc26f2265a4b68b29e539f70af0902b204b';

    const entry = Entry.newFromHex(leaf);
    const verified = smt.checkProof(root, proof, iden3.utils.bytesToHex(entry.hi()), iden3.utils.bytesToHex(entry.hv()));
    expect(verified).to.be.equal(true);
  });

  it('verify ProofClaimFull (proofClaimAssignName & proofKSign)', () => {
    const assignNameVerified = iden3.protocols.verifyProofClaimFull(proofEthName.proofAssignName, relayKOpAddr);
    expect(assignNameVerified).to.be.equal(true);

    const ksignVerified = iden3.protocols.verifyProofClaimFull(proofKSign, relayKOpAddr);
    expect(ksignVerified).to.be.equal(true);
  });

  it('newRequestIdenAssert & signIdenAssertV01 & verifySignedPacket', () => {
    const origin = 'domain.io';
    // login backend:
    const nonceDB = new iden3.protocols.nonceDB.NonceDB();
    const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, 2 * 60);

    // check that the nonce is in the nonceDB
    expect(nonceDB.search(signatureRequest.body.data.challenge)).to.be.not.equal(undefined);

    // identity wallet:
    const signedPacket = iden3.protocols.login.signIdenAssertV01(signatureRequest, usrAddr,
      { ethName: proofEthName.ethName, proofAssignName: proofEthName.proofAssignName},
      kc, kOperational, proofKSign, 3600 * 60);

    // login backend:
    const res = signedPacketVerifier.verifySignedPacketIdenAssert(signedPacket, nonceDB, origin);
    if (res == null) { return; }

    // check that the nonce returned when deleting the nonce of the signedPacket, is the same
    // than the nonce of the signatureRequest
    expect(res.nonceObj.nonce).to.be.equal(signatureRequest.body.data.challenge);

    // nonce must not be more in the nonceDB
    expect(nonceDB.search(res.nonceObj.nonce)).to.be.equal(undefined);

    expect(res.ethName).to.be.equal(proofEthName.ethName);
    expect(res.idAddr).to.be.equal(usrAddr);

    // check that an already checked signedPacket is not more longer available to be verified
    const res2 = signedPacketVerifier.verifySignedPacketIdenAssert(signedPacket, nonceDB, origin);
    expect(res2).to.be.equal(undefined);
  });
});
