import { Entry } from '../claim/entry';

const { bigInt } = require('snarkjs');

const utils = require('../utils');

/**
* Sets bit to 1 into a Uint8
* @param {Uint8} byte - Byte to set the bit
* @returns {Uint8} pos - Position of the bit to set
*/
export function setBit(byte, pos) {
  let mask = 1;
  while (pos) {
    mask <<= 1;
    pos -= 1;
  }
  return byte | mask;
}

/**
* Gets a concrete bit of a Uint8
* @param {Uint8} byte - Byte to get the bit
* @returns {Uint8} pos - Position of the bit to get
*/
export function getBit(byte, pos) {
  return (byte >> pos) & 0x01;
}

/**
* Gets binary representation of leaf position
* @param {bigInt} index - Hash index of the leaf
* @returns {Array(Uint8)} - Array of bits determining leaf position
*/
export function getIndexArray(index) {
  let k = bigInt(index);
  const res = [];

  while (!k.isZero()) {
    if (k.isOdd()) {
      res.push(1);
    } else {
      res.push(0);
    }
    k = k.shr(1);
  }

  while (res.length < 256) res.push(false);

  return res;
}

/**
* Gets proof object given a string hexadecimal encoded
* @param {String} buffHex - hexadecimal string to parse
* @returns {Object} - proof structure
*/
export function parseProof(buffHex) {
  const buffBytes = utils.hexToBytes(buffHex);
  const flag = buffBytes.readUInt8(0);
  const bitDiff = getBit(flag, 1);
  let proofStruct;
  if (bitDiff) {
    proofStruct = {
      flagExistence: flag,
      siblingsLength: buffBytes.readUInt8(1),
      siblingsBitIndex: buffBytes.slice(2, 32),
      siblings: buffBytes.slice(32, buffBytes.length - 32 * 2),
      metaData: buffBytes.slice(buffBytes.length - 32 * 2, buffBytes.length),
    };
  } else {
    proofStruct = {
      flagExistence: flag,
      siblingsLength: buffBytes.readUInt8(1),
      siblingsBitIndex: buffBytes.slice(2, 32),
      siblings: buffBytes.slice(32, buffBytes.length),
    };
  }
  return proofStruct;
}

/**
* Generates proof object
* @param {String} buffHex - hexadecimal string to parse
* @returns {Object} - structure proof
*/
export function genProofStruct(buffHex) {
  const buffBytes = utils.hexToBytes(buffHex);
  return {
    flagExistence: buffBytes.readUInt8(0),
    siblingsLength: buffBytes.readUInt8(0),
    siblings: buffBytes.slice(1, buffBytes.length - 2),
    metadataNode: buffBytes.slice(buffBytes.length - 2, buffBytes.length),
  };
}

/**
 * Import claims from the claimsDump, generated by go-iden3 in the merkletree.DumpClaims()
 * @param {Object} mt
 * @param {Object} claimsDump - array of hex strings containing the claimsDump
 */
export function importClaimsDump(mt, claimsDump) {
  for (let i = 0; i < claimsDump.length; i++) {
    const e = Entry.newFromHex(claimsDump[i]);
    const t = utils.getArrayBigIntFromBuffArrayBE(e.elements);
    mt.addClaim(t);
  }
}

/**
 * Retrieve merkle-tree proof type. It can be either existence or non-existence
 * @param {String} proofHex - Hexadecimal representation of a merkle-tree proof
 * @return {Bool} - Flag indicates if proof is existence (true) or non-existence (false)
 */
export function isMerkleTreeProofExistence(proofHex) {
  const proofBuff = parseProof(proofHex);
  const flagNonExistence = getBit(proofBuff.flagExistence, 0);
  return !flagNonExistence;
}
